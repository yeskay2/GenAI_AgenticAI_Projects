<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b9c6e32c9b5f2fed20b6916984440d88",
  "translation_date": "2025-11-11T13:04:37+00:00",
  "source_file": "08-multi-agent/code_samples/workflows-agent-framework/dotNET/03.dotnet-agent-framework-workflow-ghmodel-concurrent.md",
  "language_code": "fr"
}
-->
# âš¡ Flux de travail d'agents concurrents avec les modÃ¨les GitHub (.NET)

## ğŸ“‹ Tutoriel sur le traitement parallÃ¨le haute performance

Ce notebook illustre les **modÃ¨les de flux de travail concurrents** en utilisant le Microsoft Agent Framework pour .NET et les modÃ¨les GitHub. Vous apprendrez Ã  construire des flux de travail de traitement parallÃ¨le haute performance qui maximisent le dÃ©bit en exÃ©cutant plusieurs agents IA simultanÃ©ment tout en maintenant la coordination et la cohÃ©rence des donnÃ©es.

## ğŸ¯ Objectifs d'apprentissage

### ğŸš€ **Principes fondamentaux du traitement concurrent**
- **ExÃ©cution parallÃ¨le des agents** : ExÃ©cutez plusieurs agents IA simultanÃ©ment pour des performances maximales
- **ModÃ¨les Async/Await** : Exploitez le modÃ¨le de programmation asynchrone de .NET pour une concurrence efficace
- **IntÃ©gration des modÃ¨les GitHub** : Coordonnez plusieurs appels concurrents au service d'infÃ©rence des modÃ¨les IA de GitHub
- **Gestion des ressources** : GÃ©rez efficacement les ressources des modÃ¨les IA dans les opÃ©rations concurrentes

### ğŸ—ï¸ **Architecture avancÃ©e de la concurrence**
- **ParallÃ©lisme basÃ© sur les tÃ¢ches** : Utilisez la bibliothÃ¨que de tÃ¢ches parallÃ¨les de .NET pour une exÃ©cution concurrente optimale
- **ModÃ¨les de synchronisation** : Coordonnez les agents concurrents tout en Ã©vitant les conditions de concurrence
- **RÃ©partition de la charge** : Distribuez efficacement le travail sur la capacitÃ© de traitement concurrent disponible
- **TolÃ©rance aux pannes** : GÃ©rez les Ã©checs individuels des agents sans arrÃªter l'ensemble du flux de travail

### ğŸ¢ **Applications concurrentes en entreprise**
- **Traitement de documents Ã  haut volume** : Traitez plusieurs documents simultanÃ©ment
- **Analyse de contenu en temps rÃ©el** : Analyse concurrente des flux de donnÃ©es entrants
- **Optimisation du traitement par lots** : Maximisez le dÃ©bit pour les opÃ©rations de traitement de donnÃ©es Ã  grande Ã©chelle
- **Analyse multimodale** : Traitement parallÃ¨le de diffÃ©rents types et formats de contenu

## âš™ï¸ PrÃ©requis et configuration

### ğŸ“¦ **Packages NuGet requis**

Packages essentiels pour les flux de travail concurrents haute performance :

```xml
<!-- Core AI Framework with Async Support -->
<PackageReference Include="Microsoft.Extensions.AI" Version="9.9.0" />

<!-- Client Model Abstractions for API Communication -->
<PackageReference Include="System.ClientModel" Version="1.6.1.0" />

<!-- Azure Identity and Async LINQ for Advanced Operations -->
<PackageReference Include="Azure.Identity" Version="1.15.0" />
<PackageReference Include="System.Linq.Async" Version="6.0.3" />

<!-- Local Agent Framework References -->
<!-- Microsoft.Agents.AI.dll - Core agent abstractions with async support -->
<!-- Microsoft.Agents.AI.OpenAI.dll - GitHub Models integration with concurrency -->
```

### ğŸ”‘ **Configuration des modÃ¨les GitHub**

**Configuration de l'environnement (.env file) :**
```env
GITHUB_TOKEN=your_github_personal_access_token
GITHUB_ENDPOINT=https://models.inference.ai.azure.com
GITHUB_MODEL_ID=gpt-4o-mini
```

**ConsidÃ©rations sur le traitement concurrent :**
```csharp
// Configure for concurrent operations
var clientOptions = new OpenAIClientOptions()
{
    Endpoint = new Uri(githubEndpoint),
    // Configure connection pooling for concurrent requests
    NetworkTimeout = TimeSpan.FromMinutes(5)
};
```

### ğŸ—ï¸ **Architecture du flux de travail concurrent**

```mermaid
graph TD
    A[Workflow Input] --> B[Task Distribution]
    B --> C[Concurrent Agent Pool]
    C --> D[Agent Task 1]
    C --> E[Agent Task 2]
    C --> F[Agent Task 3]
    C --> G[Agent Task N]
    
    D --> H[Result Aggregation]
    E --> H
    F --> H
    G --> H
    
    H --> I[Synchronized Output]
    
    J[GitHub Models API] --> D
    J --> E
    J --> F
    J --> G
    
    K[.NET Task Scheduler] --> C
```

**Composants clÃ©s :**
- **BibliothÃ¨que de tÃ¢ches parallÃ¨les** : Support intÃ©grÃ© de .NET pour les opÃ©rations concurrentes
- **Pool d'agents** : Plusieurs instances d'agents pour le traitement parallÃ¨le
- **AgrÃ©gation des rÃ©sultats** : Coordination et fusion des rÃ©sultats des agents concurrents
- **Points de synchronisation** : Assurez la cohÃ©rence des donnÃ©es dans les opÃ©rations concurrentes

## ğŸ¨ **ModÃ¨les de conception de flux de travail concurrent**

### ğŸ” **Recherche et analyse parallÃ¨les**
```
Research Topic â†’ Concurrent Research Agents â†’ Result Synthesis â†’ Final Report
```

### ğŸ“Š **Traitement de donnÃ©es multi-sources**
```
Data Sources â†’ Parallel Processing Agents â†’ Data Integration â†’ Unified Output
```

### ğŸ­ **Pipeline de gÃ©nÃ©ration de contenu**
```
Content Requirements â†’ Concurrent Content Generators â†’ Quality Review â†’ Final Content
```

### ğŸ”„ **Traitement Fan-Out/Fan-In**
```
Single Input â†’ Multiple Concurrent Processors â†’ Result Aggregation â†’ Single Output
```

## ğŸ¢ **Avantages de performance en entreprise**

### âš¡ **DÃ©bit et Ã©volutivitÃ©**
- **Ã‰volutivitÃ© linÃ©aire des performances** : Ajoutez plus d'agents concurrents pour augmenter le dÃ©bit
- **Utilisation des ressources** : EfficacitÃ© maximale de la capacitÃ© des modÃ¨les IA disponibles
- **RÃ©duction du temps de traitement** : RÃ©duction significative du temps grÃ¢ce Ã  l'exÃ©cution parallÃ¨le
- **Ã‰volutivitÃ© Ã©lastique** : Ajustez dynamiquement le nombre d'agents concurrents en fonction de la charge de travail

### ğŸ›¡ï¸ **FiabilitÃ© et rÃ©silience**
- **Isolation des pannes** : Les Ã©checs individuels des agents n'affectent pas les autres opÃ©rations concurrentes
- **DÃ©gradation progressive** : Le systÃ¨me continue de fonctionner avec une capacitÃ© rÃ©duite des agents
- **RÃ©cupÃ©ration des erreurs** : MÃ©canismes de reprise automatique pour les opÃ©rations concurrentes Ã©chouÃ©es
- **RÃ©partition de la charge** : RÃ©partition uniforme du travail entre les agents disponibles

### ğŸ“Š **Surveillance des performances**
- **MÃ©triques d'exÃ©cution concurrente** : Suivez les performances de toutes les opÃ©rations parallÃ¨les
- **Analyse de l'utilisation des ressources** : Surveillez l'utilisation du CPU, de la mÃ©moire et du rÃ©seau
- **Analyse du dÃ©bit** : Mesurez les gains d'efficacitÃ© du traitement concurrent
- **DÃ©tection des goulets d'Ã©tranglement** : Identifiez et rÃ©solvez les contraintes de performance

### ğŸ”§ **DÃ©veloppement et opÃ©rations**
- **ModÃ¨le de programmation asynchrone** : Exploitez les modÃ¨les matures async/await de .NET
- **Coordination des tÃ¢ches** : CapacitÃ©s intÃ©grÃ©es de gestion et de coordination des tÃ¢ches
- **Gestion des exceptions** : Gestion complÃ¨te des erreurs pour les opÃ©rations concurrentes
- **Support de dÃ©bogage** : Outils de dÃ©bogage Visual Studio pour les flux de travail concurrents

Construisons des flux de travail IA concurrents haute performance avec .NET ! ğŸš€

## ğŸ’» ExÃ©cution du code

L'implÃ©mentation complÃ¨te est disponible dans `03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs`. Ce fichier illustre un **flux de travail concurrent Fan-Out/Fan-In** pour la planification de voyages :

### ğŸ—ï¸ **Architecture du flux de travail**

```
User Request â†’ ConcurrentStartExecutor â†’ [Researcher Agent || Planner Agent] â†’ ConcurrentAggregationExecutor â†’ Final Output
```

**Composants clÃ©s :**

1. **ConcurrentStartExecutor** : Diffuse la demande utilisateur Ã  tous les agents simultanÃ©ment
2. **Agent chercheur** : Analyse les destinations et attractions en parallÃ¨le
3. **Agent planificateur** : CrÃ©e des plans de voyage dÃ©taillÃ©s en parallÃ¨le
4. **ConcurrentAggregationExecutor** : Collecte et fusionne les rÃ©sultats des deux agents

### ğŸ¯ **ModÃ¨le Fan-Out/Fan-In**

Ce flux de travail illustre le modÃ¨le classique **Fan-Out/Fan-In** :
- **Fan-Out** : Un message d'entrÃ©e est diffusÃ© Ã  plusieurs agents simultanÃ©ment
- **Traitement concurrent** : Plusieurs agents travaillent en parallÃ¨le sur la mÃªme tÃ¢che
- **Fan-In** : Les rÃ©sultats de tous les agents sont collectÃ©s et agrÃ©gÃ©s en une seule sortie

### ğŸš€ ExÃ©cution de l'exemple

```bash
# Make the script executable (Unix/Linux/macOS)
chmod +x 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs

# Run the concurrent workflow
./03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

Ou sur Windows :
```powershell
dotnet run 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

### ğŸ“ RÃ©sultat attendu

Le flux de travail :
1. **Diffuse la demande** : Envoie "Planifiez un voyage Ã  Seattle en dÃ©cembre" Ã  deux agents
2. **Traitement concurrent** : Les deux agents travaillent simultanÃ©ment :
   - Le chercheur identifie les attractions et les dÃ©tails
   - Le planificateur crÃ©e l'itinÃ©raire et la logistique
3. **AgrÃ©gation** : Combine les deux rÃ©ponses en une sortie complÃ¨te
4. **Affiche les rÃ©sultats** : Montre le plan de voyage fusionnÃ© avec toutes les informations

### ğŸ”§ Options de personnalisation

**Ajoutez plus d'agents concurrents :**
```csharp
// Create additional specialized agents
AIAgent budgetAgent = openAIClient.GetChatClient(github_model_id).CreateAIAgent(
    name: "Budget-Agent", instructions: "Calculate travel costs...");

// Add to fan-out
var workflow = new WorkflowBuilder(startExecutor)
    .AddFanOutEdge(startExecutor, targets: [researcherAgent, plannerAgent, budgetAgent])
    .AddFanInEdge(aggregationExecutor, sources: [researcherAgent, plannerAgent, budgetAgent])
    .WithOutputFrom(aggregationExecutor)
    .Build();

// Update aggregation count
if (this._messages.Count == 3) { ... }
```

**Modifiez les instructions des agents :**
```csharp
const string ResearcherAgentInstructions = "Your custom instructions for research...";
const string PlanAgentInstructions = "Your custom instructions for planning...";
```

**Changez la tÃ¢che :**
```csharp
StreamingRun run = await InProcessExecution.StreamAsync(
    workflow, 
    "Plan a European vacation for 2 weeks in summer"
);
```

### ğŸ¯ Applications rÃ©elles

Ce modÃ¨le concurrent est idÃ©al pour :
- **CrÃ©ation de contenu** : Plusieurs rÃ©dacteurs crÃ©ant diffÃ©rentes sections simultanÃ©ment
- **Revue de code** : Plusieurs rÃ©viseurs analysant le code sous diffÃ©rents angles
- **Ã‰tude de marchÃ©** : Analyse parallÃ¨le de diffÃ©rents segments de marchÃ©
- **Traitement de documents** : Extraction, analyse et validation simultanÃ©es
- **Analyse multi-perspectives** : Obtenir des points de vue divers sur la mÃªme entrÃ©e

### ğŸ” Comprendre les exÃ©cuteurs personnalisÃ©s

**ConcurrentStartExecutor :**
- ImplÃ©mente `IMessageHandler<string>` pour accepter une entrÃ©e de type chaÃ®ne
- Diffuse les messages Ã  tous les agents connectÃ©s
- Envoie `TurnToken` pour dÃ©clencher le traitement concurrent

**ConcurrentAggregationExecutor :**
- ImplÃ©mente `IMessageHandler<ChatMessage>` pour recevoir les rÃ©ponses des agents
- Collecte les messages de maniÃ¨re thread-safe
- AgrÃ¨ge lorsque toutes les rÃ©ponses attendues sont arrivÃ©es
- Produit la sortie finale en utilisant `context.YieldOutputAsync()`

### âš¡ Avantages de performance

**Concurrent vs SÃ©quentiel :**
- SÃ©quentiel : Agent1 (30s) â†’ Agent2 (30s) = **60 secondes au total**
- Concurrent : Agent1 (30s) || Agent2 (30s) = **30 secondes au total**

**AmÃ©lioration du dÃ©bit** : Jusqu'Ã  NÃ— plus rapide pour N agents concurrents (selon la charge de travail et les ressources)

### ğŸ›¡ï¸ Gestion des erreurs

Le flux de travail gÃ¨re les Ã©checs individuels des agents de maniÃ¨re Ã©lÃ©gante :
- Si un agent Ã©choue, les autres continuent de traiter
- L'agrÃ©gateur peut implÃ©menter une logique de dÃ©lai d'attente
- Des rÃ©sultats partiels peuvent Ãªtre retournÃ©s si nÃ©cessaire

### ğŸ“Š FonctionnalitÃ©s avancÃ©es

**Nombre d'agents dynamiques :**
Modifiez la logique d'agrÃ©gation pour prendre en charge un nombre variable d'agents :

```csharp
private int _expectedAgentCount;
private readonly List<ChatMessage> _messages = [];

public async ValueTask HandleAsync(ChatMessage message, IWorkflowContext context)
{
    this._messages.Add(message);
    if (this._messages.Count == _expectedAgentCount)
    {
        // Process aggregation
    }
}
```

Ce modÃ¨le de flux de travail concurrent est essentiel pour construire des systÃ¨mes d'agents IA haute performance et Ã©volutifs !

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Avertissement** :  
Ce document a Ã©tÃ© traduit Ã  l'aide du service de traduction automatique [Co-op Translator](https://github.com/Azure/co-op-translator). Bien que nous nous efforcions d'assurer l'exactitude, veuillez noter que les traductions automatisÃ©es peuvent contenir des erreurs ou des inexactitudes. Le document original dans sa langue d'origine doit Ãªtre considÃ©rÃ© comme la source faisant autoritÃ©. Pour des informations critiques, il est recommandÃ© de recourir Ã  une traduction humaine professionnelle. Nous ne sommes pas responsables des malentendus ou des interprÃ©tations erronÃ©es rÃ©sultant de l'utilisation de cette traduction.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->