<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b9c6e32c9b5f2fed20b6916984440d88",
  "translation_date": "2025-11-11T13:17:25+00:00",
  "source_file": "08-multi-agent/code_samples/workflows-agent-framework/dotNET/03.dotnet-agent-framework-workflow-ghmodel-concurrent.md",
  "language_code": "it"
}
-->
# ‚ö° Flussi di lavoro concorrenti con i modelli GitHub (.NET)

## üìã Tutorial sul processamento parallelo ad alte prestazioni

Questo notebook dimostra i **modelli di flussi di lavoro concorrenti** utilizzando il Microsoft Agent Framework per .NET e i modelli GitHub. Imparerai a costruire flussi di lavoro ad alte prestazioni e processamento parallelo che massimizzano la capacit√† eseguendo simultaneamente pi√π agenti AI, mantenendo al contempo coordinazione e coerenza dei dati.

## üéØ Obiettivi di apprendimento

### üöÄ **Fondamenti del processamento concorrente**
- **Esecuzione parallela degli agenti**: Esegui pi√π agenti AI simultaneamente per ottenere prestazioni massime
- **Pattern Async/Await**: Sfrutta il modello di programmazione asincrona di .NET per una concorrenza efficiente
- **Integrazione con i modelli GitHub**: Coordina pi√π chiamate concorrenti al servizio di inferenza dei modelli AI di GitHub
- **Gestione delle risorse**: Gestisci in modo efficiente le risorse dei modelli AI durante le operazioni concorrenti

### üèóÔ∏è **Architettura avanzata della concorrenza**
- **Parallelismo basato su Task**: Utilizza la Task Parallel Library di .NET per un'esecuzione concorrente ottimale
- **Pattern di sincronizzazione**: Coordina gli agenti concorrenti evitando condizioni di gara
- **Bilanciamento del carico**: Distribuisci il lavoro in modo efficiente sulla capacit√† di processamento concorrente disponibile
- **Tolleranza ai guasti**: Gestisci i fallimenti individuali degli agenti senza interrompere l'intero flusso di lavoro

### üè¢ **Applicazioni aziendali concorrenti**
- **Processamento di documenti ad alto volume**: Elabora pi√π documenti simultaneamente
- **Analisi dei contenuti in tempo reale**: Analisi concorrente di flussi di dati in arrivo
- **Ottimizzazione del processamento batch**: Massimizza la capacit√† per operazioni di processamento dati su larga scala
- **Analisi multi-modale**: Processamento parallelo di diversi tipi e formati di contenuti

## ‚öôÔ∏è Prerequisiti e configurazione

### üì¶ **Pacchetti NuGet richiesti**

Pacchetti essenziali per flussi di lavoro concorrenti ad alte prestazioni:

```xml
<!-- Core AI Framework with Async Support -->
<PackageReference Include="Microsoft.Extensions.AI" Version="9.9.0" />

<!-- Client Model Abstractions for API Communication -->
<PackageReference Include="System.ClientModel" Version="1.6.1.0" />

<!-- Azure Identity and Async LINQ for Advanced Operations -->
<PackageReference Include="Azure.Identity" Version="1.15.0" />
<PackageReference Include="System.Linq.Async" Version="6.0.3" />

<!-- Local Agent Framework References -->
<!-- Microsoft.Agents.AI.dll - Core agent abstractions with async support -->
<!-- Microsoft.Agents.AI.OpenAI.dll - GitHub Models integration with concurrency -->
```

### üîë **Configurazione dei modelli GitHub**

**Configurazione dell'ambiente (.env file):**
```env
GITHUB_TOKEN=your_github_personal_access_token
GITHUB_ENDPOINT=https://models.inference.ai.azure.com
GITHUB_MODEL_ID=gpt-4o-mini
```

**Considerazioni sul processamento concorrente:**
```csharp
// Configure for concurrent operations
var clientOptions = new OpenAIClientOptions()
{
    Endpoint = new Uri(githubEndpoint),
    // Configure connection pooling for concurrent requests
    NetworkTimeout = TimeSpan.FromMinutes(5)
};
```

### üèóÔ∏è **Architettura del flusso di lavoro concorrente**

```mermaid
graph TD
    A[Workflow Input] --> B[Task Distribution]
    B --> C[Concurrent Agent Pool]
    C --> D[Agent Task 1]
    C --> E[Agent Task 2]
    C --> F[Agent Task 3]
    C --> G[Agent Task N]
    
    D --> H[Result Aggregation]
    E --> H
    F --> H
    G --> H
    
    H --> I[Synchronized Output]
    
    J[GitHub Models API] --> D
    J --> E
    J --> F
    J --> G
    
    K[.NET Task Scheduler] --> C
```

**Componenti chiave:**
- **Task Parallel Library**: Supporto integrato di .NET per operazioni concorrenti
- **Pool di agenti**: Pi√π istanze di agenti per il processamento parallelo
- **Aggregazione dei risultati**: Coordinazione e fusione dei risultati degli agenti concorrenti
- **Punti di sincronizzazione**: Garantire la coerenza dei dati durante le operazioni concorrenti

## üé® **Modelli di progettazione dei flussi di lavoro concorrenti**

### üîç **Ricerca e analisi parallela**
```
Research Topic ‚Üí Concurrent Research Agents ‚Üí Result Synthesis ‚Üí Final Report
```

### üìä **Processamento dati da pi√π fonti**
```
Data Sources ‚Üí Parallel Processing Agents ‚Üí Data Integration ‚Üí Unified Output
```

### üé≠ **Pipeline di generazione dei contenuti**
```
Content Requirements ‚Üí Concurrent Content Generators ‚Üí Quality Review ‚Üí Final Content
```

### üîÑ **Processamento Fan-Out/Fan-In**
```
Single Input ‚Üí Multiple Concurrent Processors ‚Üí Result Aggregation ‚Üí Single Output
```

## üè¢ **Vantaggi prestazionali aziendali**

### ‚ö° **Capacit√† e scalabilit√†**
- **Scalabilit√† lineare delle prestazioni**: Aggiungi pi√π agenti concorrenti per aumentare la capacit√†
- **Utilizzo delle risorse**: Massima efficienza della capacit√† disponibile dei modelli AI
- **Riduzione dei tempi di processamento**: Riduzione significativa dei tempi grazie all'esecuzione parallela
- **Scalabilit√† elastica**: Regola dinamicamente il numero di agenti concorrenti in base al carico di lavoro

### üõ°Ô∏è **Affidabilit√† e resilienza**
- **Isolamento dei guasti**: I fallimenti individuali degli agenti non influenzano le altre operazioni concorrenti
- **Degradazione graduale**: Il sistema continua a funzionare con una capacit√† ridotta degli agenti
- **Recupero dagli errori**: Meccanismi di retry automatici per operazioni concorrenti fallite
- **Distribuzione del carico**: Distribuzione uniforme del lavoro tra gli agenti disponibili

### üìä **Monitoraggio delle prestazioni**
- **Metriche di esecuzione concorrente**: Traccia le prestazioni di tutte le operazioni parallele
- **Analisi dell'utilizzo delle risorse**: Monitora CPU, memoria e utilizzo della rete
- **Analisi della capacit√†**: Misura i guadagni di efficienza derivanti dal processamento concorrente
- **Rilevamento dei colli di bottiglia**: Identifica e risolvi i vincoli prestazionali

### üîß **Sviluppo e operazioni**
- **Modello di programmazione asincrona**: Sfrutta i maturi pattern async/await di .NET
- **Coordinazione dei task**: Capacit√† integrate di gestione e coordinazione dei task
- **Gestione delle eccezioni**: Gestione completa degli errori per operazioni concorrenti
- **Supporto al debugging**: Strumenti di debugging di Visual Studio per flussi di lavoro concorrenti

Costruiamo flussi di lavoro AI concorrenti ad alte prestazioni con .NET! üöÄ

## üíª Esecuzione del codice

L'implementazione completa √® disponibile in `03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs`. Questo file dimostra un **flusso di lavoro concorrente Fan-Out/Fan-In** per la pianificazione di viaggi:

### üèóÔ∏è **Architettura del flusso di lavoro**

```
User Request ‚Üí ConcurrentStartExecutor ‚Üí [Researcher Agent || Planner Agent] ‚Üí ConcurrentAggregationExecutor ‚Üí Final Output
```

**Componenti chiave:**

1. **ConcurrentStartExecutor**: Trasmette la richiesta dell'utente a tutti gli agenti simultaneamente
2. **Researcher Agent**: Analizza destinazioni e attrazioni in modo concorrente
3. **Planner Agent**: Crea piani di viaggio dettagliati in modo concorrente
4. **ConcurrentAggregationExecutor**: Raccoglie e unisce i risultati di entrambi gli agenti

### üéØ **Pattern Fan-Out/Fan-In**

Questo flusso di lavoro dimostra il classico pattern **Fan-Out/Fan-In**:
- **Fan-Out**: Un messaggio di input viene trasmesso simultaneamente a pi√π agenti
- **Processamento concorrente**: Pi√π agenti lavorano in parallelo sullo stesso compito
- **Fan-In**: I risultati di tutti gli agenti vengono raccolti e aggregati in un unico output

### üöÄ Esecuzione dell'esempio

```bash
# Make the script executable (Unix/Linux/macOS)
chmod +x 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs

# Run the concurrent workflow
./03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

Oppure su Windows:
```powershell
dotnet run 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

### üìù Output previsto

Il flusso di lavoro:
1. **Trasmette la richiesta**: Invia "Pianifica un viaggio a Seattle a dicembre" a entrambi gli agenti
2. **Processamento concorrente**: Entrambi gli agenti lavorano simultaneamente:
   - Il ricercatore identifica attrazioni e dettagli
   - Il pianificatore crea itinerari e logistica
3. **Aggregazione**: Combina entrambe le risposte in un output completo
4. **Mostra i risultati**: Visualizza il piano di viaggio unificato con tutte le informazioni

### üîß Opzioni di personalizzazione

**Aggiungi pi√π agenti concorrenti:**
```csharp
// Create additional specialized agents
AIAgent budgetAgent = openAIClient.GetChatClient(github_model_id).CreateAIAgent(
    name: "Budget-Agent", instructions: "Calculate travel costs...");

// Add to fan-out
var workflow = new WorkflowBuilder(startExecutor)
    .AddFanOutEdge(startExecutor, targets: [researcherAgent, plannerAgent, budgetAgent])
    .AddFanInEdge(aggregationExecutor, sources: [researcherAgent, plannerAgent, budgetAgent])
    .WithOutputFrom(aggregationExecutor)
    .Build();

// Update aggregation count
if (this._messages.Count == 3) { ... }
```

**Modifica le istruzioni degli agenti:**
```csharp
const string ResearcherAgentInstructions = "Your custom instructions for research...";
const string PlanAgentInstructions = "Your custom instructions for planning...";
```

**Cambia il compito:**
```csharp
StreamingRun run = await InProcessExecution.StreamAsync(
    workflow, 
    "Plan a European vacation for 2 weeks in summer"
);
```

### üéØ Applicazioni reali

Questo pattern concorrente √® ideale per:
- **Creazione di contenuti**: Pi√π scrittori che creano sezioni diverse simultaneamente
- **Revisione del codice**: Pi√π revisori che analizzano il codice da prospettive diverse
- **Ricerca di mercato**: Analisi parallela di diversi segmenti di mercato
- **Processamento di documenti**: Estrazione, analisi e validazione concorrenti
- **Analisi multi-prospettiva**: Ottenere punti di vista diversi sullo stesso input

### üîç Comprendere gli executor personalizzati

**ConcurrentStartExecutor:**
- Implementa `IMessageHandler<string>` per accettare input di tipo stringa
- Trasmette messaggi a tutti gli agenti connessi
- Invia `TurnToken` per attivare il processamento concorrente

**ConcurrentAggregationExecutor:**
- Implementa `IMessageHandler<ChatMessage>` per ricevere risposte dagli agenti
- Raccoglie i messaggi in modo thread-safe
- Aggrega quando arrivano tutte le risposte previste
- Fornisce l'output finale utilizzando `context.YieldOutputAsync()`

### ‚ö° Vantaggi prestazionali

**Concorrenza vs Sequenziale:**
- Sequenziale: Agente1 (30s) ‚Üí Agente2 (30s) = **60 secondi totali**
- Concorrenza: Agente1 (30s) || Agente2 (30s) = **30 secondi totali**

**Miglioramento della capacit√†**: Fino a N√ó pi√π veloce per N agenti concorrenti (a seconda del carico di lavoro e delle risorse)

### üõ°Ô∏è Gestione degli errori

Il flusso di lavoro gestisce i fallimenti individuali degli agenti in modo efficace:
- Se un agente fallisce, gli altri continuano a processare
- L'aggregatore pu√≤ implementare logiche di timeout
- Possono essere restituiti risultati parziali se necessario

### üìä Funzionalit√† avanzate

**Numero dinamico di agenti:**
Modifica la logica di aggregazione per supportare un numero variabile di agenti:

```csharp
private int _expectedAgentCount;
private readonly List<ChatMessage> _messages = [];

public async ValueTask HandleAsync(ChatMessage message, IWorkflowContext context)
{
    this._messages.Add(message);
    if (this._messages.Count == _expectedAgentCount)
    {
        // Process aggregation
    }
}
```

Questo pattern di flusso di lavoro concorrente √® essenziale per costruire sistemi di agenti AI ad alte prestazioni e scalabili!

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Disclaimer**:  
Questo documento √® stato tradotto utilizzando il servizio di traduzione AI [Co-op Translator](https://github.com/Azure/co-op-translator). Sebbene ci impegniamo per garantire l'accuratezza, si prega di notare che le traduzioni automatiche potrebbero contenere errori o imprecisioni. Il documento originale nella sua lingua nativa dovrebbe essere considerato la fonte autorevole. Per informazioni critiche, si raccomanda una traduzione professionale umana. Non siamo responsabili per eventuali incomprensioni o interpretazioni errate derivanti dall'uso di questa traduzione.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->