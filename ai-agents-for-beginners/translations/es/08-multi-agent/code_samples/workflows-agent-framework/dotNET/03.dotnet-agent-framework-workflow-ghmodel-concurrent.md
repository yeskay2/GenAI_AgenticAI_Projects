<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "b9c6e32c9b5f2fed20b6916984440d88",
  "translation_date": "2025-11-11T13:05:15+00:00",
  "source_file": "08-multi-agent/code_samples/workflows-agent-framework/dotNET/03.dotnet-agent-framework-workflow-ghmodel-concurrent.md",
  "language_code": "es"
}
-->
# âš¡ Flujos de trabajo concurrentes de agentes con modelos de GitHub (.NET)

## ğŸ“‹ Tutorial de procesamiento paralelo de alto rendimiento

Este cuaderno demuestra **patrones de flujo de trabajo concurrentes** utilizando el Microsoft Agent Framework para .NET y modelos de GitHub. AprenderÃ¡s a construir flujos de trabajo de procesamiento paralelo de alto rendimiento que maximizan el rendimiento ejecutando mÃºltiples agentes de IA simultÃ¡neamente mientras se mantiene la coordinaciÃ³n y la consistencia de los datos.

## ğŸ¯ Objetivos de aprendizaje

### ğŸš€ **Fundamentos del procesamiento concurrente**
- **EjecuciÃ³n paralela de agentes**: Ejecuta mÃºltiples agentes de IA simultÃ¡neamente para obtener el mÃ¡ximo rendimiento
- **Patrones Async/Await**: Aprovecha el modelo de programaciÃ³n asÃ­ncrona de .NET para una concurrencia eficiente
- **IntegraciÃ³n con modelos de GitHub**: Coordina mÃºltiples llamadas concurrentes al servicio de inferencia de modelos de IA de GitHub
- **GestiÃ³n de recursos**: Administra eficientemente los recursos de modelos de IA en operaciones concurrentes

### ğŸ—ï¸ **Arquitectura avanzada de concurrencia**
- **Paralelismo basado en tareas**: Utiliza la biblioteca de tareas paralelas de .NET para una ejecuciÃ³n concurrente Ã³ptima
- **Patrones de sincronizaciÃ³n**: Coordina agentes concurrentes evitando condiciones de carrera
- **Balanceo de carga**: Distribuye el trabajo eficientemente entre la capacidad de procesamiento concurrente disponible
- **Tolerancia a fallos**: Maneja fallos individuales de agentes sin detener todo el flujo de trabajo

### ğŸ¢ **Aplicaciones concurrentes empresariales**
- **Procesamiento de documentos de alto volumen**: Procesa mÃºltiples documentos simultÃ¡neamente
- **AnÃ¡lisis de contenido en tiempo real**: AnÃ¡lisis concurrente de flujos de datos entrantes
- **OptimizaciÃ³n de procesamiento por lotes**: Maximiza el rendimiento en operaciones de procesamiento de datos a gran escala
- **AnÃ¡lisis multimodal**: Procesamiento paralelo de diferentes tipos y formatos de contenido

## âš™ï¸ Requisitos previos y configuraciÃ³n

### ğŸ“¦ **Paquetes NuGet necesarios**

Paquetes esenciales para flujos de trabajo concurrentes de alto rendimiento:

```xml
<!-- Core AI Framework with Async Support -->
<PackageReference Include="Microsoft.Extensions.AI" Version="9.9.0" />

<!-- Client Model Abstractions for API Communication -->
<PackageReference Include="System.ClientModel" Version="1.6.1.0" />

<!-- Azure Identity and Async LINQ for Advanced Operations -->
<PackageReference Include="Azure.Identity" Version="1.15.0" />
<PackageReference Include="System.Linq.Async" Version="6.0.3" />

<!-- Local Agent Framework References -->
<!-- Microsoft.Agents.AI.dll - Core agent abstractions with async support -->
<!-- Microsoft.Agents.AI.OpenAI.dll - GitHub Models integration with concurrency -->
```

### ğŸ”‘ **ConfiguraciÃ³n de modelos de GitHub**

**ConfiguraciÃ³n del entorno (archivo .env):**
```env
GITHUB_TOKEN=your_github_personal_access_token
GITHUB_ENDPOINT=https://models.inference.ai.azure.com
GITHUB_MODEL_ID=gpt-4o-mini
```

**Consideraciones sobre procesamiento concurrente:**
```csharp
// Configure for concurrent operations
var clientOptions = new OpenAIClientOptions()
{
    Endpoint = new Uri(githubEndpoint),
    // Configure connection pooling for concurrent requests
    NetworkTimeout = TimeSpan.FromMinutes(5)
};
```

### ğŸ—ï¸ **Arquitectura de flujo de trabajo concurrente**

```mermaid
graph TD
    A[Workflow Input] --> B[Task Distribution]
    B --> C[Concurrent Agent Pool]
    C --> D[Agent Task 1]
    C --> E[Agent Task 2]
    C --> F[Agent Task 3]
    C --> G[Agent Task N]
    
    D --> H[Result Aggregation]
    E --> H
    F --> H
    G --> H
    
    H --> I[Synchronized Output]
    
    J[GitHub Models API] --> D
    J --> E
    J --> F
    J --> G
    
    K[.NET Task Scheduler] --> C
```

**Componentes clave:**
- **Biblioteca de tareas paralelas**: Soporte integrado de .NET para operaciones concurrentes
- **Pool de agentes**: MÃºltiples instancias de agentes para procesamiento paralelo
- **AgregaciÃ³n de resultados**: CoordinaciÃ³n y combinaciÃ³n de resultados de agentes concurrentes
- **Puntos de sincronizaciÃ³n**: Garantiza la consistencia de datos en operaciones concurrentes

## ğŸ¨ **Patrones de diseÃ±o de flujo de trabajo concurrente**

### ğŸ” **InvestigaciÃ³n y anÃ¡lisis paralelos**
```
Research Topic â†’ Concurrent Research Agents â†’ Result Synthesis â†’ Final Report
```

### ğŸ“Š **Procesamiento de datos de mÃºltiples fuentes**
```
Data Sources â†’ Parallel Processing Agents â†’ Data Integration â†’ Unified Output
```

### ğŸ­ **Pipeline de generaciÃ³n de contenido**
```
Content Requirements â†’ Concurrent Content Generators â†’ Quality Review â†’ Final Content
```

### ğŸ”„ **Procesamiento Fan-Out/Fan-In**
```
Single Input â†’ Multiple Concurrent Processors â†’ Result Aggregation â†’ Single Output
```

## ğŸ¢ **Beneficios de rendimiento empresarial**

### âš¡ **Rendimiento y escalabilidad**
- **Escalado lineal de rendimiento**: Agrega mÃ¡s agentes concurrentes para aumentar el rendimiento
- **UtilizaciÃ³n de recursos**: MÃ¡xima eficiencia de la capacidad de modelos de IA disponibles
- **ReducciÃ³n del tiempo de procesamiento**: ReducciÃ³n significativa del tiempo mediante ejecuciÃ³n paralela
- **Escalado elÃ¡stico**: Ajusta dinÃ¡micamente la cantidad de agentes concurrentes segÃºn la carga de trabajo

### ğŸ›¡ï¸ **Fiabilidad y resiliencia**
- **Aislamiento de fallos**: Los fallos individuales de agentes no afectan otras operaciones concurrentes
- **DegradaciÃ³n gradual**: El sistema sigue funcionando con capacidad reducida de agentes
- **RecuperaciÃ³n de errores**: Mecanismos automÃ¡ticos de reintento para operaciones concurrentes fallidas
- **DistribuciÃ³n de carga**: DistribuciÃ³n uniforme del trabajo entre los agentes disponibles

### ğŸ“Š **Monitoreo de rendimiento**
- **MÃ©tricas de ejecuciÃ³n concurrente**: Rastrea el rendimiento de todas las operaciones paralelas
- **AnÃ¡lisis de uso de recursos**: Monitorea el uso de CPU, memoria y red
- **AnÃ¡lisis de rendimiento**: Mide las ganancias de eficiencia del procesamiento concurrente
- **DetecciÃ³n de cuellos de botella**: Identifica y resuelve restricciones de rendimiento

### ğŸ”§ **Desarrollo y operaciones**
- **Modelo de programaciÃ³n asÃ­ncrona**: Aprovecha los patrones maduros de async/await de .NET
- **CoordinaciÃ³n de tareas**: Capacidades integradas de gestiÃ³n y coordinaciÃ³n de tareas
- **Manejo de excepciones**: Manejo integral de errores en operaciones concurrentes
- **Soporte de depuraciÃ³n**: Herramientas de depuraciÃ³n de Visual Studio para flujos de trabajo concurrentes

Â¡Construyamos flujos de trabajo de IA concurrentes de alto rendimiento con .NET! ğŸš€

## ğŸ’» EjecuciÃ³n del cÃ³digo

La implementaciÃ³n completa estÃ¡ disponible en `03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs`. Este archivo demuestra un flujo de trabajo concurrente **Fan-Out/Fan-In** para planificaciÃ³n de viajes:

### ğŸ—ï¸ **Arquitectura del flujo de trabajo**

```
User Request â†’ ConcurrentStartExecutor â†’ [Researcher Agent || Planner Agent] â†’ ConcurrentAggregationExecutor â†’ Final Output
```

**Componentes clave:**

1. **ConcurrentStartExecutor**: Difunde la solicitud del usuario a todos los agentes simultÃ¡neamente
2. **Agente investigador**: Analiza destinos y atracciones de forma concurrente
3. **Agente planificador**: Crea planes de viaje detallados de forma concurrente
4. **ConcurrentAggregationExecutor**: Recoge y combina resultados de ambos agentes

### ğŸ¯ **PatrÃ³n Fan-Out/Fan-In**

Este flujo de trabajo demuestra el clÃ¡sico patrÃ³n **Fan-Out/Fan-In**:
- **Fan-Out**: Un mensaje de entrada se difunde a mÃºltiples agentes simultÃ¡neamente
- **Procesamiento concurrente**: MÃºltiples agentes trabajan en paralelo en la misma tarea
- **Fan-In**: Los resultados de todos los agentes se recogen y se agregan en una salida Ãºnica

### ğŸš€ EjecuciÃ³n del ejemplo

```bash
# Make the script executable (Unix/Linux/macOS)
chmod +x 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs

# Run the concurrent workflow
./03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

O en Windows:
```powershell
dotnet run 03.dotnet-agent-framework-workflow-ghmodel-concurrent.cs
```

### ğŸ“ Salida esperada

El flujo de trabajo:
1. **Difunde la solicitud**: EnvÃ­a "Planifica un viaje a Seattle en diciembre" a ambos agentes
2. **Procesamiento concurrente**: Ambos agentes trabajan simultÃ¡neamente:
   - El investigador identifica atracciones y detalles
   - El planificador crea el itinerario y la logÃ­stica
3. **AgregaciÃ³n**: Combina ambas respuestas en una salida integral
4. **Muestra resultados**: Presenta el plan de viaje combinado con toda la informaciÃ³n

### ğŸ”§ Opciones de personalizaciÃ³n

**Agregar mÃ¡s agentes concurrentes:**
```csharp
// Create additional specialized agents
AIAgent budgetAgent = openAIClient.GetChatClient(github_model_id).CreateAIAgent(
    name: "Budget-Agent", instructions: "Calculate travel costs...");

// Add to fan-out
var workflow = new WorkflowBuilder(startExecutor)
    .AddFanOutEdge(startExecutor, targets: [researcherAgent, plannerAgent, budgetAgent])
    .AddFanInEdge(aggregationExecutor, sources: [researcherAgent, plannerAgent, budgetAgent])
    .WithOutputFrom(aggregationExecutor)
    .Build();

// Update aggregation count
if (this._messages.Count == 3) { ... }
```

**Modificar instrucciones de los agentes:**
```csharp
const string ResearcherAgentInstructions = "Your custom instructions for research...";
const string PlanAgentInstructions = "Your custom instructions for planning...";
```

**Cambiar la tarea:**
```csharp
StreamingRun run = await InProcessExecution.StreamAsync(
    workflow, 
    "Plan a European vacation for 2 weeks in summer"
);
```

### ğŸ¯ Aplicaciones en el mundo real

Este patrÃ³n concurrente es ideal para:
- **CreaciÃ³n de contenido**: MÃºltiples escritores creando diferentes secciones simultÃ¡neamente
- **RevisiÃ³n de cÃ³digo**: MÃºltiples revisores analizando cÃ³digo desde diferentes perspectivas
- **InvestigaciÃ³n de mercado**: AnÃ¡lisis paralelo de diferentes segmentos de mercado
- **Procesamiento de documentos**: ExtracciÃ³n, anÃ¡lisis y validaciÃ³n concurrentes
- **AnÃ¡lisis multiperspectiva**: ObtenciÃ³n de puntos de vista diversos sobre la misma entrada

### ğŸ” Comprendiendo los ejecutores personalizados

**ConcurrentStartExecutor:**
- Implementa `IMessageHandler<string>` para aceptar entradas de tipo string
- Difunde mensajes a todos los agentes conectados
- EnvÃ­a `TurnToken` para activar el procesamiento concurrente

**ConcurrentAggregationExecutor:**
- Implementa `IMessageHandler<ChatMessage>` para recibir respuestas de agentes
- Recoge mensajes de manera segura para hilos
- Agrega cuando llegan todas las respuestas esperadas
- Produce la salida final utilizando `context.YieldOutputAsync()`

### âš¡ Beneficios de rendimiento

**Concurrente vs Secuencial:**
- Secuencial: Agente1 (30s) â†’ Agente2 (30s) = **60 segundos en total**
- Concurrente: Agente1 (30s) || Agente2 (30s) = **30 segundos en total**

**Mejora del rendimiento**: Hasta NÃ— mÃ¡s rÃ¡pido para N agentes concurrentes (dependiendo de la carga de trabajo y los recursos)

### ğŸ›¡ï¸ Manejo de errores

El flujo de trabajo maneja fallos individuales de agentes de manera eficiente:
- Si un agente falla, los demÃ¡s continÃºan procesando
- El agregador puede implementar lÃ³gica de tiempo de espera
- Se pueden devolver resultados parciales si es necesario

### ğŸ“Š Funciones avanzadas

**Cantidad dinÃ¡mica de agentes:**
Modifica la lÃ³gica de agregaciÃ³n para admitir cantidades variables de agentes:

```csharp
private int _expectedAgentCount;
private readonly List<ChatMessage> _messages = [];

public async ValueTask HandleAsync(ChatMessage message, IWorkflowContext context)
{
    this._messages.Add(message);
    if (this._messages.Count == _expectedAgentCount)
    {
        // Process aggregation
    }
}
```

Â¡Este patrÃ³n de flujo de trabajo concurrente es esencial para construir sistemas de agentes de IA escalables y de alto rendimiento!

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Descargo de responsabilidad**:  
Este documento ha sido traducido utilizando el servicio de traducciÃ³n automÃ¡tica [Co-op Translator](https://github.com/Azure/co-op-translator). Aunque nos esforzamos por lograr precisiÃ³n, tenga en cuenta que las traducciones automÃ¡ticas pueden contener errores o imprecisiones. El documento original en su idioma nativo debe considerarse la fuente autorizada. Para informaciÃ³n crÃ­tica, se recomienda una traducciÃ³n profesional realizada por humanos. No nos hacemos responsables de malentendidos o interpretaciones errÃ³neas que surjan del uso de esta traducciÃ³n.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->